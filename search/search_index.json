{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Welcome to the documentation for the <code>folder-replicator</code> package.</p> <p>This is a Python utility for file backup and synchronization.</p> <p>The design of this package is based on the Strategy Patternand the Factory Method Pattern.</p> <p>The main goal of this package is to provide a simple and flexible way to synchronize files between two folders, for now, the synchronization is only one-way, from the source folder to the destination folder.</p> <p>The synchronization is done by comparing the files in the source folder with the files in the destination folder. The files that are in the source folder but not in the destination folder are copied to the destination folder, and the files that are in the destination folder but not in the source folder are deleted from the destination folder (if the <code>delete</code> parameter is set to <code>True</code>).</p> <p>The package provides a default strategy for synchronization, the <code>SyncStrategyLocal</code>, which uses the local file system to copy the files.</p>"},{"location":"index.html#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>Getting Started</p> </li> <li> <p>Reference</p> </li> </ul>"},{"location":"getting-started.html","title":"Getting Started","text":"<p>This is a guide to help you get started with the project. It will walk you through the steps to get the project up and running on your local machine.</p>"},{"location":"getting-started.html#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have met the following requirements:</p> <ul> <li>You have installed Python 3.8 or later.</li> <li>You have installed Poetry.</li> <li>You have a Linux machine. The project may work on other operating systems, but it has only been tested on Linux.</li> </ul>"},{"location":"getting-started.html#running-the-project","title":"Running the project","text":"<p>To set up the project, follow these steps:</p> <ol> <li>Step 1</li> </ol> <pre><code>poetry install\n</code></pre> <ol> <li>Step 2</li> </ol> <pre><code>poetry run folder-replicator --help\n</code></pre>"},{"location":"getting-started.html#configuration","title":"Configuration","text":"<p>The execution of the project can be configured using command-line arguments. You can see the available options by running the following command:</p> <pre><code>poetry run folder-replicator --help\n</code></pre> <p>Here is an example of how to run the project with some options:</p> <pre><code>poetry run folder-replicator --source /path/to/source --destination /path/to/destination --schedule=\"0 0 * * *\" --verbose --log-file /path/to/log-file.log\n\n</code></pre>"},{"location":"getting-started.html#environment-variables","title":"Environment Variables","text":"<p>The project uses environment variables to configure the application. You can set these variables in a <code>.env</code> file in the root of the project.</p> <pre><code># .env\nFR_VERBOSE=true\n</code></pre>"},{"location":"getting-started.html#running-the-project-docker","title":"Running the project (Docker)","text":"<p>To run the project, follow these steps:</p> <ol> <li>Step 1</li> </ol> <p>Edit the <code>docker-compose.yml</code> file to set the source and destination folders.</p> <pre><code># docker-compose.yml\nversion: '3.8'\n\nservices:\n  folder-replicator:\n    image: folder-replicator:latest\n    volumes:\n      - /path/to/source:/source\n      - /path/to/destination:/destination\n</code></pre> <ol> <li>Step 2</li> </ol> <p>In the same file you can also edit the schedule and other options. Check the Configuration section for more information.</p> <ol> <li>Step 3</li> </ol> <p>Run the following command to start the container:</p> <pre><code>docker compose up --build\n</code></pre> <p>Optionally, you can run the container in the background:</p> <pre><code>docker compose up --build --detach\n</code></pre>"},{"location":"reference.html","title":"docs/reference.md","text":"<p>This is the reference documentation for the <code>folder_replicator</code> package.</p>"},{"location":"reference.html#modules","title":"Modules","text":""},{"location":"reference.html#folder_replicator.__main__","title":"<code>folder_replicator.__main__</code>","text":"<p>Main module for the folder-replicator package.</p>"},{"location":"reference.html#folder_replicator.__main__.main","title":"<code>main()</code>","text":"<p>Main function for the folder-replicator package.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>folder_replicator/__main__.py</code> <pre><code>def main() -&gt; None:\n    \"\"\"\n    Main function for the folder-replicator package.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n\n    args = _parse_args()\n    logger = fr_logger.get_logger(verbose=args.verbose, log_file=args.log_file)\n    logger.info(\"Starting folder-replicator\")\n    logger.info(f\"Syncing from {args.source} to {args.destination}\")\n    logger.info(f\"Syncing every {args.schedule}\")\n    logger.info(f\"Syncing options: recursive={args.recursive}, delete={args.delete}, dry_run={args.dry_run}\")\n\n    sync_strategy = SyncStrategyFactory.create_strategy(\n        args.type, args.source, args.destination, args.recursive, args.delete, args.dry_run\n    )\n\n    # The client code picks a concrete strategy and passes it to the context.\n    # The client should be aware of the differences between strategies in order\n    # to make the right choice.\n    sync_context = SyncContext(sync_strategy)\n\n    while True:\n        sync_context._strategy.sync()\n        sleep(5)\n\n        next_sync = get_seconds_until_next_sync(args.schedule)\n        logger.info(f\"Next sync in {next_sync} seconds\")\n\n        sleep(next_sync)\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder","title":"<code>folder_replicator.Folder</code>","text":""},{"location":"reference.html#folder_replicator.Folder.Folder","title":"<code>Folder</code>","text":"<p>Represents a folder in the filesystem.</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>class Folder:\n    \"\"\"\n    Represents a folder in the filesystem.\n    \"\"\"\n\n    def __init__(self, path: str, recursive: bool = True, delete: bool = True) -&gt; None:\n        \"\"\"\n        Initialize the Folder object.\n\n        Args:\n            path (str): the path to the folder\n            recursive (bool): whether to sync the folder recursively\n            delete (bool): whether to delete files that are not in the source folder\n\n        Returns:\n            None\n        \"\"\"\n        self.path = pathlib.Path(path)\n        self.recursive = recursive\n        self.delete = delete\n        self.files = self.get_files()\n        self.hash = self.__calculate_folder_hash()\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the Folder object.\n\n        Args:\n            None\n\n        Returns:\n            str: the string representation of the Folder object\n        \"\"\"\n        return f\"Folder(path={self.path.__str__()}, files={self.files})\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns a string representation of the Folder object.\n\n        Args:\n            None\n\n        Returns:\n            str: the string representation of the Folder object\n        \"\"\"\n        return f\"Folder(path={self.path}, hash={self.hash})\"\n\n    def __eq__(self, other) -&gt; bool:\n        \"\"\"\n        Compare two Folder objects for equality.\n\n        Args:\n            other (Folder): the other Folder object to compare\n\n        Returns:\n            bool: whether the two Folder objects are equal\n        \"\"\"\n        return self.hash == other.hash\n\n    def __calculate_folder_hash(self) -&gt; str:\n        \"\"\"\n        Calculate the hash of a folder.\n\n        Args:\n            None\n\n        Returns:\n            str: the hash of the folder\n        \"\"\"\n        hasher = hashlib.md5()\n        for file, hash in self.files.items():\n            hasher.update(file.name.encode())\n            hasher.update(hash.__str__().encode())\n            hasher.update(hash.encode())\n        return hasher.hexdigest()\n\n    def __calculate_file_hash(self, file_path: pathlib.Path) -&gt; str:\n        \"\"\"\n        Calculate the hash of a file.\n\n        Args:\n            file_path (pathlib.Path): the path to the file\n\n        Returns:\n            str: the hash of the file\n        \"\"\"\n        hash = hashlib.md5()\n        try:\n            with open(file_path.__str__(), \"rb\") as file:\n                while chunk := file.read(4096):\n                    hash.update(chunk)\n        except FileNotFoundError:\n            return None\n        except PermissionError:\n            return None\n        return hash.hexdigest()\n\n    def get_files(self) -&gt; dict:\n        \"\"\"\n        Discover the files in the folder, recursively if specified.\n\n        Args:\n            None\n\n        Returns:\n            dict: a dictionary of files in the folder with the relative path as the key and the checksum as the value\n        \"\"\"\n        if self.recursive:\n            files = {\n                file: self.__calculate_file_hash(file.resolve())\n                for file in self.path.rglob(\"*\")\n                if file.is_file()\n            }\n        else:\n            files = {\n                file: self.__calculate_file_hash(file.resolve())\n                for file in self.path.glob(\"*\")\n                if file.is_file()\n            }\n\n        # Sort the files by hash to ensure a consistent order\n        files = {k: v for k, v in sorted(files.items(), key=lambda item: item[1])}\n        return files\n\n    def refresh(self) -&gt; None:\n        \"\"\"\n        Refresh the files in the folder.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        self.files = self.get_files()\n        self.hash = self.__calculate_folder_hash()\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.__calculate_file_hash","title":"<code>__calculate_file_hash(file_path)</code>","text":"<p>Calculate the hash of a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>Path</code> <p>the path to the file</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the hash of the file</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def __calculate_file_hash(self, file_path: pathlib.Path) -&gt; str:\n    \"\"\"\n    Calculate the hash of a file.\n\n    Args:\n        file_path (pathlib.Path): the path to the file\n\n    Returns:\n        str: the hash of the file\n    \"\"\"\n    hash = hashlib.md5()\n    try:\n        with open(file_path.__str__(), \"rb\") as file:\n            while chunk := file.read(4096):\n                hash.update(chunk)\n    except FileNotFoundError:\n        return None\n    except PermissionError:\n        return None\n    return hash.hexdigest()\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.__calculate_folder_hash","title":"<code>__calculate_folder_hash()</code>","text":"<p>Calculate the hash of a folder.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the hash of the folder</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def __calculate_folder_hash(self) -&gt; str:\n    \"\"\"\n    Calculate the hash of a folder.\n\n    Args:\n        None\n\n    Returns:\n        str: the hash of the folder\n    \"\"\"\n    hasher = hashlib.md5()\n    for file, hash in self.files.items():\n        hasher.update(file.name.encode())\n        hasher.update(hash.__str__().encode())\n        hasher.update(hash.encode())\n    return hasher.hexdigest()\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare two Folder objects for equality.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Folder</code> <p>the other Folder object to compare</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>whether the two Folder objects are equal</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Compare two Folder objects for equality.\n\n    Args:\n        other (Folder): the other Folder object to compare\n\n    Returns:\n        bool: whether the two Folder objects are equal\n    \"\"\"\n    return self.hash == other.hash\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.__init__","title":"<code>__init__(path, recursive=True, delete=True)</code>","text":"<p>Initialize the Folder object.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the path to the folder</p> required <code>recursive</code> <code>bool</code> <p>whether to sync the folder recursively</p> <code>True</code> <code>delete</code> <code>bool</code> <p>whether to delete files that are not in the source folder</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def __init__(self, path: str, recursive: bool = True, delete: bool = True) -&gt; None:\n    \"\"\"\n    Initialize the Folder object.\n\n    Args:\n        path (str): the path to the folder\n        recursive (bool): whether to sync the folder recursively\n        delete (bool): whether to delete files that are not in the source folder\n\n    Returns:\n        None\n    \"\"\"\n    self.path = pathlib.Path(path)\n    self.recursive = recursive\n    self.delete = delete\n    self.files = self.get_files()\n    self.hash = self.__calculate_folder_hash()\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the Folder object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the string representation of the Folder object</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the Folder object.\n\n    Args:\n        None\n\n    Returns:\n        str: the string representation of the Folder object\n    \"\"\"\n    return f\"Folder(path={self.path}, hash={self.hash})\"\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.__str__","title":"<code>__str__()</code>","text":"<p>Returns a string representation of the Folder object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the string representation of the Folder object</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a string representation of the Folder object.\n\n    Args:\n        None\n\n    Returns:\n        str: the string representation of the Folder object\n    \"\"\"\n    return f\"Folder(path={self.path.__str__()}, files={self.files})\"\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.get_files","title":"<code>get_files()</code>","text":"<p>Discover the files in the folder, recursively if specified.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>a dictionary of files in the folder with the relative path as the key and the checksum as the value</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def get_files(self) -&gt; dict:\n    \"\"\"\n    Discover the files in the folder, recursively if specified.\n\n    Args:\n        None\n\n    Returns:\n        dict: a dictionary of files in the folder with the relative path as the key and the checksum as the value\n    \"\"\"\n    if self.recursive:\n        files = {\n            file: self.__calculate_file_hash(file.resolve())\n            for file in self.path.rglob(\"*\")\n            if file.is_file()\n        }\n    else:\n        files = {\n            file: self.__calculate_file_hash(file.resolve())\n            for file in self.path.glob(\"*\")\n            if file.is_file()\n        }\n\n    # Sort the files by hash to ensure a consistent order\n    files = {k: v for k, v in sorted(files.items(), key=lambda item: item[1])}\n    return files\n</code></pre>"},{"location":"reference.html#folder_replicator.Folder.Folder.refresh","title":"<code>refresh()</code>","text":"<p>Refresh the files in the folder.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>folder_replicator/Folder.py</code> <pre><code>def refresh(self) -&gt; None:\n    \"\"\"\n    Refresh the files in the folder.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    self.files = self.get_files()\n    self.hash = self.__calculate_folder_hash()\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncContext","title":"<code>folder_replicator.SyncContext</code>","text":""},{"location":"reference.html#folder_replicator.SyncContext.SyncContext","title":"<code>SyncContext</code>","text":"<p>The SyncContext defines the interface of interest to clients.</p> Source code in <code>folder_replicator/SyncContext.py</code> <pre><code>class SyncContext:\n    \"\"\"\n    The SyncContext defines the interface of interest to clients.\n    \"\"\"\n\n    def __init__(self, strategy: SyncStrategy) -&gt; None:\n        \"\"\"\n        SyncContext accepts a strategy object through the constructor and saves it\n        for future use.\n        \"\"\"\n\n        self._strategy = strategy\n\n    @property\n    def strategy(self) -&gt; SyncStrategy:\n        \"\"\"\n        The SyncContext maintains a reference to one of the Strategy objects. The\n        SyncContext does not know the concrete class of a strategy. It should work\n        with all strategies via the SyncStrategy interface.\n        \"\"\"\n\n        return self._strategy\n\n    @strategy.setter\n    def strategy(self, strategy: SyncStrategy) -&gt; None:\n        \"\"\"\n        SyncContext allows replacing a Strategy object at runtime.\n        \"\"\"\n\n        self._strategy = strategy\n\n    def get_number_of_files(self) -&gt; int:\n        \"\"\"\n        The SyncContext delegates some work to the Strategy object instead of\n        implementing multiple versions of the algorithm on its own.\n        \"\"\"\n\n        return len(self._strategy.source.files)\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncContext.SyncContext.strategy","title":"<code>strategy: SyncStrategy</code>  <code>property</code> <code>writable</code>","text":"<p>The SyncContext maintains a reference to one of the Strategy objects. The SyncContext does not know the concrete class of a strategy. It should work with all strategies via the SyncStrategy interface.</p>"},{"location":"reference.html#folder_replicator.SyncContext.SyncContext.__init__","title":"<code>__init__(strategy)</code>","text":"<p>SyncContext accepts a strategy object through the constructor and saves it for future use.</p> Source code in <code>folder_replicator/SyncContext.py</code> <pre><code>def __init__(self, strategy: SyncStrategy) -&gt; None:\n    \"\"\"\n    SyncContext accepts a strategy object through the constructor and saves it\n    for future use.\n    \"\"\"\n\n    self._strategy = strategy\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncContext.SyncContext.get_number_of_files","title":"<code>get_number_of_files()</code>","text":"<p>The SyncContext delegates some work to the Strategy object instead of implementing multiple versions of the algorithm on its own.</p> Source code in <code>folder_replicator/SyncContext.py</code> <pre><code>def get_number_of_files(self) -&gt; int:\n    \"\"\"\n    The SyncContext delegates some work to the Strategy object instead of\n    implementing multiple versions of the algorithm on its own.\n    \"\"\"\n\n    return len(self._strategy.source.files)\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyFactory","title":"<code>folder_replicator.SyncStrategyFactory</code>","text":""},{"location":"reference.html#folder_replicator.SyncStrategyFactory.SyncStrategyFactory","title":"<code>SyncStrategyFactory</code>","text":"<p>Factory class for creating SyncStrategy objects</p> Source code in <code>folder_replicator/SyncStrategyFactory.py</code> <pre><code>class SyncStrategyFactory:\n    \"\"\"Factory class for creating SyncStrategy objects\"\"\"\n\n    @staticmethod\n    def create_strategy(\n        strategy_type: str,\n        source: str,\n        destination: str,\n        recursive: bool,\n        delete: bool,\n        dry_run: bool,\n    ) -&gt; SyncStrategy:\n        \"\"\"\n        Create a SyncStrategy object based on the strategy_type provided.\n\n        Args:\n            strategy_type: str - the type of strategy to create\n\n        Returns:\n            SyncStrategy - the created strategy\n        \"\"\"\n\n        logger = fr_logger.get_logger()\n\n        if strategy_type == \"local\":\n            logger.info(\"Creating local sync strategy\")\n            return SyncStrategyLocal(source, destination, recursive, delete, dry_run)\n        else:\n            logger.error(f\"Unknown strategy type: {strategy_type}\")\n            raise ValueError(f\"Unknown strategy type: {strategy_type}\")\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyFactory.SyncStrategyFactory.create_strategy","title":"<code>create_strategy(strategy_type, source, destination, recursive, delete, dry_run)</code>  <code>staticmethod</code>","text":"<p>Create a SyncStrategy object based on the strategy_type provided.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_type</code> <code>str</code> <p>str - the type of strategy to create</p> required <p>Returns:</p> Type Description <code>SyncStrategy</code> <p>SyncStrategy - the created strategy</p> Source code in <code>folder_replicator/SyncStrategyFactory.py</code> <pre><code>@staticmethod\ndef create_strategy(\n    strategy_type: str,\n    source: str,\n    destination: str,\n    recursive: bool,\n    delete: bool,\n    dry_run: bool,\n) -&gt; SyncStrategy:\n    \"\"\"\n    Create a SyncStrategy object based on the strategy_type provided.\n\n    Args:\n        strategy_type: str - the type of strategy to create\n\n    Returns:\n        SyncStrategy - the created strategy\n    \"\"\"\n\n    logger = fr_logger.get_logger()\n\n    if strategy_type == \"local\":\n        logger.info(\"Creating local sync strategy\")\n        return SyncStrategyLocal(source, destination, recursive, delete, dry_run)\n    else:\n        logger.error(f\"Unknown strategy type: {strategy_type}\")\n        raise ValueError(f\"Unknown strategy type: {strategy_type}\")\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyLocal","title":"<code>folder_replicator.SyncStrategyLocal</code>","text":""},{"location":"reference.html#folder_replicator.SyncStrategyLocal.SyncStrategyLocal","title":"<code>SyncStrategyLocal</code>","text":"<p>               Bases: <code>SyncStrategy</code></p> <p>Concrete Sync Strategy class that implements the local sync strategy.</p> <p>The SyncContext uses this class to call the algorithm defined by the Concrete SyncStrategy.</p> Source code in <code>folder_replicator/SyncStrategyLocal.py</code> <pre><code>class SyncStrategyLocal(SyncStrategy):\n    \"\"\"\n    Concrete Sync Strategy class that implements the local sync strategy.\n\n    The SyncContext uses this class to call the algorithm defined by the Concrete\n    SyncStrategy.\n    \"\"\"\n\n    def __init__(\n        self, source: str, destination: str, recursive: bool, delete: bool, dry_run: bool\n    ) -&gt; None:\n        \"\"\"\n        Constructor for the SyncStrategyLocal class.\n        \"\"\"\n        self.source = Folder(source, recursive=recursive, delete=delete)\n        self.destination = Folder(destination, recursive=recursive, delete=delete)\n        self.dry_run = dry_run\n\n    def sync(self) -&gt; None:\n        \"\"\"\n        The sync method is the main method that the SyncContext will use to\n        perform the sync operation.\n        \"\"\"\n        logger = fr_logger.get_logger()\n        logger.info(f\"Syncing folders {self.source.path} and {self.destination.path}\")\n        self.source.refresh()\n        self.destination.refresh()\n        if self.source.hash == self.destination.hash:\n            logger.info(\n                f\"Folders {self.source.path}:{self.source.hash} and {self.destination.path}:{self.source.hash} are in sync\"\n            )\n            return\n\n        # Get files in source and destination\n        source_files = self.source.files\n        destination_files = self.destination.files\n\n        # Get files that are in source but not in destination\n        files_to_copy = {}\n        for path, hash in source_files.items():\n            if hash not in destination_files.values():\n                files_to_copy[path.resolve()] = hash\n                continue\n            for file, file_hash in destination_files.items():\n                if hash == file_hash:\n                    if path.name != file.name:\n                        print(path.name, file.name)\n                        files_to_copy[path.resolve()] = hash\n                        continue\n                    if path.stat().st_mtime &gt; file.stat().st_mtime:\n                        files_to_copy[path.resolve()] = hash\n\n        if logger.isEnabledFor(fr_logger.logging.DEBUG):\n            logger.debug(f\"Source files: {source_files}\")\n            logger.debug(f\"Destination files: {destination_files}\")\n            logger.debug(f\"Files to copy: {files_to_copy}\")\n\n        if self.source.delete:\n            # Get files that are in destination but not in source\n            files_to_delete = {}\n            for path, hash in destination_files.items():\n                if hash not in source_files.values():\n                    files_to_delete[path.resolve()] = hash\n                    continue\n                for file, file_hash in source_files.items():\n                    if hash == file_hash:\n                        if path.name != file.name:\n                            files_to_delete[path.resolve()] = hash\n                            continue\n                        if path.stat().st_mtime &gt; file.stat().st_mtime:\n                            files_to_delete[path.resolve()] = hash\n\n            if logger.isEnabledFor(fr_logger.logging.DEBUG):\n                logger.debug(f\"Files to delete: {files_to_delete}\")\n\n            temp_files = []\n            # Delete files from destination that are not in source\n            for file in files_to_delete:\n                logger.info(f\"Deleting file {file}\")\n                if self.dry_run:\n                    continue\n                try:\n                    # Copy files to temp file before deleting\n                    temp_file = Path(f\"{file}.bak\")\n                    temp_files.append(temp_file)\n                    shutil.copy2(file, temp_file)\n                    file.unlink()\n                except FileNotFoundError:\n                    logger.error(f\"File {file} not found in destination\")\n                    continue\n                except PermissionError:\n                    logger.error(f\"Permission denied to delete file {file}\")\n                    continue\n                except Exception as e:\n                    logger.error(f\"Error deleting file {file}: {e}\")\n                    continue\n\n        # Copy files from source to destination\n        self.__copy(files_to_copy)\n\n        if self.source.delete:\n            # Clean up temp files\n            self.__clean_bak_files(temp_files)\n            self.__remove_empty_folders(self.destination.path)\n\n        self.source.refresh()\n        self.destination.refresh()\n        logger.info(\"Sync complete\")\n\n    def __copy_file(self, src, dst, buffer_size=1024*1024):\n        \"\"\"\n        Copy a file from source to destination using a buffer.\n\n        Args:\n            src: str - the source file path\n            dst: str - the destination file path\n            buffer_size: int - the buffer size to use\n\n        Returns:\n            None\n        \"\"\"\n        copied_size = 0\n        logger = fr_logger.get_logger()\n\n        with open(src, 'rb') as file_src, open(dst, 'wb') as file_dst:\n            while True:\n                buf = file_src.read(buffer_size)\n                if not buf:\n                    break\n                file_dst.write(buf)\n                copied_size += len(buf)\n\n        shutil.copystat(src, dst)\n        if logger.isEnabledFor(fr_logger.logging.DEBUG):\n            logger.debug(f\"Copied {copied_size} bytes from {src} to {dst}\")\n\n    def __copy(self, files_to_copy: dict) -&gt; None:\n        \"\"\"\n        Helper method to copy files from the source to the destination.\n\n        Args:\n            files_to_copy: dict - the files to copy\n\n        Returns:\n            None\n        \"\"\"\n        logger = fr_logger.get_logger()\n        logger.info(f\"Copying folders {self.source.path} to {self.destination.path}\")\n\n        # Copy files from source to destination\n        for path in files_to_copy.keys():\n            source_path = path\n            try:\n                relative_path = source_path.relative_to(self.source.path.resolve())\n            except ValueError:\n                logger.error(\n                    f\"File {source_path} is not relative to the source directory {self.source.path}\"\n                )\n                continue\n\n            destination_path = self.destination.path.resolve() / relative_path\n            logger.info(f\"Copying file {source_path} to {destination_path}\")\n\n            if self.dry_run:\n                continue\n\n            try:\n                # Create necessary directories in the destination path\n                destination_path.parent.mkdir(parents=True, exist_ok=True)\n\n                # Copy the file\n                # shutil.copy2(source_path, destination_path)\n                self.__copy_file(source_path, destination_path)\n            except FileNotFoundError:\n                logger.error(f\"File {source_path} not found in source\")\n                continue\n            except PermissionError:\n                logger.error(f\"Permission denied to copy file {source_path}\")\n                continue\n            except Exception as e:\n                logger.error(f\"Error copying file {source_path}: {e}\")\n                continue\n\n        logger.info(\"Copy complete\")\n\n    def __clean_bak_files(self, temp_files: list) -&gt; None:\n        \"\"\"\n        Helper method to clean up temp files.\n\n        Args:\n            temp_files: list - the temp files to clean up\n\n        Returns:\n            None\n        \"\"\"\n        logger = fr_logger.get_logger()\n        if logger.isEnabledFor(fr_logger.logging.DEBUG):\n            logger.debug(f\"Temp files: {temp_files}\")\n        logger.info(\"Cleaning up temp files\")\n\n        for file in temp_files:\n            logger.info(f\"Removing temp file {file}\")\n            if self.dry_run:\n                continue\n            try:\n                file.unlink()\n            except FileNotFoundError:\n                logger.error(f\"File {file} not found\")\n                continue\n            except PermissionError:\n                logger.error(f\"Permission denied to delete file {file}\")\n                continue\n            except Exception as e:\n                logger.error(f\"Error deleting file {file}: {e}\")\n                continue\n\n        logger.info(\"Temp file cleanup complete\")\n\n    def __remove_empty_folders(self, path: Path) -&gt; None:\n        \"\"\"\n        Helper method to remove empty folders.\n\n        Args:\n            path: Path - the path to the folder\n\n        Returns:\n            None\n        \"\"\"\n        logger = fr_logger.get_logger()\n        logger.info(f\"Removing empty folders in {path}\")\n\n        for folder in path.iterdir():\n            if folder.is_dir():\n                self.__remove_empty_folders(folder)\n                try:\n                    folder.rmdir()  # This will only remove the subdirectory if it is empty\n                    logger.info(f\"Folder {folder} deleted\")\n                except OSError as e:\n                    if e.errno == 39:  # Directory not empty\n                        logger.debug(f\"Folder {folder} is not empty\")\n                    else:\n                        logger.error(f\"Error deleting folder {folder}: {e}\")\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyLocal.SyncStrategyLocal.__clean_bak_files","title":"<code>__clean_bak_files(temp_files)</code>","text":"<p>Helper method to clean up temp files.</p> <p>Parameters:</p> Name Type Description Default <code>temp_files</code> <code>list</code> <p>list - the temp files to clean up</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>folder_replicator/SyncStrategyLocal.py</code> <pre><code>def __clean_bak_files(self, temp_files: list) -&gt; None:\n    \"\"\"\n    Helper method to clean up temp files.\n\n    Args:\n        temp_files: list - the temp files to clean up\n\n    Returns:\n        None\n    \"\"\"\n    logger = fr_logger.get_logger()\n    if logger.isEnabledFor(fr_logger.logging.DEBUG):\n        logger.debug(f\"Temp files: {temp_files}\")\n    logger.info(\"Cleaning up temp files\")\n\n    for file in temp_files:\n        logger.info(f\"Removing temp file {file}\")\n        if self.dry_run:\n            continue\n        try:\n            file.unlink()\n        except FileNotFoundError:\n            logger.error(f\"File {file} not found\")\n            continue\n        except PermissionError:\n            logger.error(f\"Permission denied to delete file {file}\")\n            continue\n        except Exception as e:\n            logger.error(f\"Error deleting file {file}: {e}\")\n            continue\n\n    logger.info(\"Temp file cleanup complete\")\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyLocal.SyncStrategyLocal.__copy","title":"<code>__copy(files_to_copy)</code>","text":"<p>Helper method to copy files from the source to the destination.</p> <p>Parameters:</p> Name Type Description Default <code>files_to_copy</code> <code>dict</code> <p>dict - the files to copy</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>folder_replicator/SyncStrategyLocal.py</code> <pre><code>def __copy(self, files_to_copy: dict) -&gt; None:\n    \"\"\"\n    Helper method to copy files from the source to the destination.\n\n    Args:\n        files_to_copy: dict - the files to copy\n\n    Returns:\n        None\n    \"\"\"\n    logger = fr_logger.get_logger()\n    logger.info(f\"Copying folders {self.source.path} to {self.destination.path}\")\n\n    # Copy files from source to destination\n    for path in files_to_copy.keys():\n        source_path = path\n        try:\n            relative_path = source_path.relative_to(self.source.path.resolve())\n        except ValueError:\n            logger.error(\n                f\"File {source_path} is not relative to the source directory {self.source.path}\"\n            )\n            continue\n\n        destination_path = self.destination.path.resolve() / relative_path\n        logger.info(f\"Copying file {source_path} to {destination_path}\")\n\n        if self.dry_run:\n            continue\n\n        try:\n            # Create necessary directories in the destination path\n            destination_path.parent.mkdir(parents=True, exist_ok=True)\n\n            # Copy the file\n            # shutil.copy2(source_path, destination_path)\n            self.__copy_file(source_path, destination_path)\n        except FileNotFoundError:\n            logger.error(f\"File {source_path} not found in source\")\n            continue\n        except PermissionError:\n            logger.error(f\"Permission denied to copy file {source_path}\")\n            continue\n        except Exception as e:\n            logger.error(f\"Error copying file {source_path}: {e}\")\n            continue\n\n    logger.info(\"Copy complete\")\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyLocal.SyncStrategyLocal.__copy_file","title":"<code>__copy_file(src, dst, buffer_size=1024 * 1024)</code>","text":"<p>Copy a file from source to destination using a buffer.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <p>str - the source file path</p> required <code>dst</code> <p>str - the destination file path</p> required <code>buffer_size</code> <p>int - the buffer size to use</p> <code>1024 * 1024</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>folder_replicator/SyncStrategyLocal.py</code> <pre><code>def __copy_file(self, src, dst, buffer_size=1024*1024):\n    \"\"\"\n    Copy a file from source to destination using a buffer.\n\n    Args:\n        src: str - the source file path\n        dst: str - the destination file path\n        buffer_size: int - the buffer size to use\n\n    Returns:\n        None\n    \"\"\"\n    copied_size = 0\n    logger = fr_logger.get_logger()\n\n    with open(src, 'rb') as file_src, open(dst, 'wb') as file_dst:\n        while True:\n            buf = file_src.read(buffer_size)\n            if not buf:\n                break\n            file_dst.write(buf)\n            copied_size += len(buf)\n\n    shutil.copystat(src, dst)\n    if logger.isEnabledFor(fr_logger.logging.DEBUG):\n        logger.debug(f\"Copied {copied_size} bytes from {src} to {dst}\")\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyLocal.SyncStrategyLocal.__init__","title":"<code>__init__(source, destination, recursive, delete, dry_run)</code>","text":"<p>Constructor for the SyncStrategyLocal class.</p> Source code in <code>folder_replicator/SyncStrategyLocal.py</code> <pre><code>def __init__(\n    self, source: str, destination: str, recursive: bool, delete: bool, dry_run: bool\n) -&gt; None:\n    \"\"\"\n    Constructor for the SyncStrategyLocal class.\n    \"\"\"\n    self.source = Folder(source, recursive=recursive, delete=delete)\n    self.destination = Folder(destination, recursive=recursive, delete=delete)\n    self.dry_run = dry_run\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyLocal.SyncStrategyLocal.__remove_empty_folders","title":"<code>__remove_empty_folders(path)</code>","text":"<p>Helper method to remove empty folders.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path - the path to the folder</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>folder_replicator/SyncStrategyLocal.py</code> <pre><code>def __remove_empty_folders(self, path: Path) -&gt; None:\n    \"\"\"\n    Helper method to remove empty folders.\n\n    Args:\n        path: Path - the path to the folder\n\n    Returns:\n        None\n    \"\"\"\n    logger = fr_logger.get_logger()\n    logger.info(f\"Removing empty folders in {path}\")\n\n    for folder in path.iterdir():\n        if folder.is_dir():\n            self.__remove_empty_folders(folder)\n            try:\n                folder.rmdir()  # This will only remove the subdirectory if it is empty\n                logger.info(f\"Folder {folder} deleted\")\n            except OSError as e:\n                if e.errno == 39:  # Directory not empty\n                    logger.debug(f\"Folder {folder} is not empty\")\n                else:\n                    logger.error(f\"Error deleting folder {folder}: {e}\")\n</code></pre>"},{"location":"reference.html#folder_replicator.SyncStrategyLocal.SyncStrategyLocal.sync","title":"<code>sync()</code>","text":"<p>The sync method is the main method that the SyncContext will use to perform the sync operation.</p> Source code in <code>folder_replicator/SyncStrategyLocal.py</code> <pre><code>def sync(self) -&gt; None:\n    \"\"\"\n    The sync method is the main method that the SyncContext will use to\n    perform the sync operation.\n    \"\"\"\n    logger = fr_logger.get_logger()\n    logger.info(f\"Syncing folders {self.source.path} and {self.destination.path}\")\n    self.source.refresh()\n    self.destination.refresh()\n    if self.source.hash == self.destination.hash:\n        logger.info(\n            f\"Folders {self.source.path}:{self.source.hash} and {self.destination.path}:{self.source.hash} are in sync\"\n        )\n        return\n\n    # Get files in source and destination\n    source_files = self.source.files\n    destination_files = self.destination.files\n\n    # Get files that are in source but not in destination\n    files_to_copy = {}\n    for path, hash in source_files.items():\n        if hash not in destination_files.values():\n            files_to_copy[path.resolve()] = hash\n            continue\n        for file, file_hash in destination_files.items():\n            if hash == file_hash:\n                if path.name != file.name:\n                    print(path.name, file.name)\n                    files_to_copy[path.resolve()] = hash\n                    continue\n                if path.stat().st_mtime &gt; file.stat().st_mtime:\n                    files_to_copy[path.resolve()] = hash\n\n    if logger.isEnabledFor(fr_logger.logging.DEBUG):\n        logger.debug(f\"Source files: {source_files}\")\n        logger.debug(f\"Destination files: {destination_files}\")\n        logger.debug(f\"Files to copy: {files_to_copy}\")\n\n    if self.source.delete:\n        # Get files that are in destination but not in source\n        files_to_delete = {}\n        for path, hash in destination_files.items():\n            if hash not in source_files.values():\n                files_to_delete[path.resolve()] = hash\n                continue\n            for file, file_hash in source_files.items():\n                if hash == file_hash:\n                    if path.name != file.name:\n                        files_to_delete[path.resolve()] = hash\n                        continue\n                    if path.stat().st_mtime &gt; file.stat().st_mtime:\n                        files_to_delete[path.resolve()] = hash\n\n        if logger.isEnabledFor(fr_logger.logging.DEBUG):\n            logger.debug(f\"Files to delete: {files_to_delete}\")\n\n        temp_files = []\n        # Delete files from destination that are not in source\n        for file in files_to_delete:\n            logger.info(f\"Deleting file {file}\")\n            if self.dry_run:\n                continue\n            try:\n                # Copy files to temp file before deleting\n                temp_file = Path(f\"{file}.bak\")\n                temp_files.append(temp_file)\n                shutil.copy2(file, temp_file)\n                file.unlink()\n            except FileNotFoundError:\n                logger.error(f\"File {file} not found in destination\")\n                continue\n            except PermissionError:\n                logger.error(f\"Permission denied to delete file {file}\")\n                continue\n            except Exception as e:\n                logger.error(f\"Error deleting file {file}: {e}\")\n                continue\n\n    # Copy files from source to destination\n    self.__copy(files_to_copy)\n\n    if self.source.delete:\n        # Clean up temp files\n        self.__clean_bak_files(temp_files)\n        self.__remove_empty_folders(self.destination.path)\n\n    self.source.refresh()\n    self.destination.refresh()\n    logger.info(\"Sync complete\")\n</code></pre>"},{"location":"reference.html#folder_replicator.interfaces.SyncStrategy","title":"<code>folder_replicator.interfaces.SyncStrategy</code>","text":""},{"location":"reference.html#folder_replicator.interfaces.SyncStrategy.SyncStrategy","title":"<code>SyncStrategy</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The Strategy interface declares operations common to all supported versions of sync procedure.</p> <p>The SyncContext uses this interface to call the algorithm defined by Concrete SyncStrategies.</p> Source code in <code>folder_replicator/interfaces/SyncStrategy.py</code> <pre><code>class SyncStrategy(ABC):\n    \"\"\"\n    The Strategy interface declares operations common to all supported versions\n    of sync procedure.\n\n    The SyncContext uses this interface to call the algorithm defined by Concrete\n    SyncStrategies.\n\n    \"\"\"\n\n    @abstractmethod\n    def sync(self):\n        \"\"\"\n        The sync method is the main method that the SyncContext will use to\n        perform the sync operation.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference.html#folder_replicator.interfaces.SyncStrategy.SyncStrategy.sync","title":"<code>sync()</code>  <code>abstractmethod</code>","text":"<p>The sync method is the main method that the SyncContext will use to perform the sync operation.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>folder_replicator/interfaces/SyncStrategy.py</code> <pre><code>@abstractmethod\ndef sync(self):\n    \"\"\"\n    The sync method is the main method that the SyncContext will use to\n    perform the sync operation.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference.html#folder_replicator.lib.logger","title":"<code>folder_replicator.lib.logger</code>","text":""},{"location":"reference.html#folder_replicator.lib.logger.get_logger","title":"<code>get_logger(name=__name__, verbose=False, log_file=None)</code>","text":"<p>Set up a logger instance and return it.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str - name of the logger</p> <code>__name__</code> <code>verbose</code> <code>bool</code> <p>bool - whether to log debug messages</p> <code>False</code> <code>log_file</code> <code>str</code> <p>str - path to the log file</p> <code>None</code> <p>Returns:</p> Name Type Description <code>logger</code> <code>Logger</code> <p>logging.Logger - the logger instance</p> Source code in <code>folder_replicator/lib/logger.py</code> <pre><code>def get_logger(name: str = __name__, verbose: bool = False, log_file: str = None) -&gt; logging.Logger:\n    \"\"\"\n    Set up a logger instance and return it.\n\n    Args:\n        name: str - name of the logger\n        verbose: bool - whether to log debug messages\n        log_file: str - path to the log file\n\n    Returns:\n        logger: logging.Logger - the logger instance\n    \"\"\"\n    if \"FR_VERBOSE\" in os.environ:\n        verbose = True\n\n    logger = logging.getLogger(name)\n\n    # logger itself is ensured to be a singleton\n    # but handlers should only be added once\n    if len(logger.handlers) == 0:\n        logger.setLevel(logging.DEBUG if verbose else logging.INFO)\n        console_handler = logging.StreamHandler(sys.stderr)\n        formatter = logging.Formatter(\n            \"%(asctime)s [%(levelname)s] %(message)s\", datefmt=\"%Y-%m-%d %H:%M:%S %z\"\n        )\n        console_handler.setFormatter(formatter)\n        logger.addHandler(console_handler)\n\n        if log_file := DEFAULT_LOG_FILE:\n            file_handler = logging.FileHandler(log_file)\n\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n    return logger\n</code></pre>"},{"location":"reference.html#folder_replicator.lib.sync_scheduler","title":"<code>folder_replicator.lib.sync_scheduler</code>","text":""},{"location":"reference.html#folder_replicator.lib.sync_scheduler.get_seconds_until_next_sync","title":"<code>get_seconds_until_next_sync(cron)</code>","text":"<p>Get the number of seconds until the next sync</p> <p>Returns:</p> Type Description <code>int</code> <p>int - the number of seconds until the next sync</p> Source code in <code>folder_replicator/lib/sync_scheduler.py</code> <pre><code>def get_seconds_until_next_sync(cron: str) -&gt; int:\n    \"\"\"\n    Get the number of seconds until the next sync\n\n    Args:\n        None\n\n    Returns:\n        int - the number of seconds until the next sync\n    \"\"\"\n    now = datetime.datetime.now()\n    _cron = croniter.croniter(cron, now)\n    next_sync = _cron.get_next(datetime.datetime)\n    return (next_sync - now).seconds\n</code></pre>"}]}